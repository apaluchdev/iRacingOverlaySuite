using GameOverlay.Drawing;
using GameOverlay.Windows;
using System;
using System.Collections.Generic;
using System.Reflection.Metadata;
using System.Windows.Interop;
using System.Windows;

namespace iRacingOverlaySuite.Overlays
{
    public enum Location
    {
        TopLeft,
        TopRight,
        BottomLeft,
        BottomRight,
        Center
    }

    public class Overlay : IDisposable
    {
        private readonly GraphicsWindow _window;
        private List<Action<Graphics>> DrawActions = new List<Action<Graphics>>();

        private const string IRACING_WINDOW_NAME = "iRacing.com Simulator";
        private bool _attachedToWindow = false;

        protected readonly Dictionary<string, SolidBrush> _brushes;
        protected readonly Dictionary<string, Font> _fonts;
        protected readonly Dictionary<string, Image> _images;

        protected IRData IRData = new IRData();

        public event EventHandler? SetupCompleted;

        public int Width { get; private set; }
        public int Height { get; private set; }

        public int OffsetX { get; private set; }

        public int OffsetY { get; private set; }

        public RECT GameWindow;

        public bool DebugMode { get; set; } = false;

        private Location _location;

        public Image ABSOn;

        public Overlay(int x, int y, Location location, int width, int height)
        {
            _brushes = new Dictionary<string, SolidBrush>();
            _fonts = new Dictionary<string, Font>();
            _images = new Dictionary<string, Image>();

            Width = width;
            Height = height;

            OffsetX = x;
            OffsetY = y;

            _location = location;

            var gfx = new Graphics()
            {
                MeasureFPS = true,
                PerPrimitiveAntiAliasing = true,
                TextAntiAliasing = true
            };

            _window = new GraphicsWindow(x, y, width, height, gfx)
            {
                FPS = 50,
                IsTopmost = true,
                IsVisible = true,
            };

            _window.DestroyGraphics += _window_DestroyGraphics;
            _window.DrawGraphics += _window_DrawGraphics;
            _window.SetupGraphics += _window_SetupGraphics;
        }

        #region SetupGraphics

        private void _window_SetupGraphics(object sender, SetupGraphicsEventArgs e)
        {
            AttachToWindow();

            var gfx = e.Graphics;

            ABSOn = gfx.CreateImage(@"C:\Users\Adrian\Desktop\abs.png");

            if (e.RecreateResources)
            {
                foreach (var pair in _brushes) pair.Value.Dispose();
                foreach (var pair in _images) pair.Value.Dispose();
            }

            SetupBrushes(gfx);

            if (e.RecreateResources) return;

            _fonts["arial"] = gfx.CreateFont("Arial", 12);
            _fonts["consolas"] = gfx.CreateFont("Consolas", 14);

            SetupCompleted?.Invoke(this, e);
        }

        #endregion

        protected void AddDrawActions(List<Action<Graphics>> drawActions)
        {
            foreach (var drawAction in drawActions)
            {
                DrawActions.Add(drawAction);
            }  
        }

        private void _window_DrawGraphics(object sender, DrawGraphicsEventArgs e)
        {
            var gfx = e.Graphics;

            // If we are not attached to the window, attempt to do so every 5 seconds
            if (!_attachedToWindow)
            {
                if (DateTime.Now.Second % 5 == 0)
                    AttachToWindow();
            }

            IRData.UpdateData();

            RefreshData();

            // Draw list of actions generated by child class
            Draw(gfx);
        }

        private void Draw(Graphics gfx)
        {
            foreach (var action in DrawActions)
            {
                action(gfx);
            }

            if (DebugMode)
            {
                DrawDebug(gfx);
            }
        }

        public void DrawDebug(Graphics gfx)
        {
            gfx.DrawTextWithBackground(_fonts["consolas"], 11, _brushes["white"], _brushes["black"], 0, 0, $"X: {_window.X}, Y: {_window.Y}");
            gfx.DrawTextWithBackground(_fonts["consolas"], 11, _brushes["white"], _brushes["black"], 0, 15, $"Width: {_window.Width}, Height: {_window.Height}");
        }

        public void AttachToWindow(string windowName = IRACING_WINDOW_NAME)
        {
            IntPtr windowHandle = Win32Helper.FindWindow(null, windowName);

            if (windowHandle != IntPtr.Zero)
            {
                // TODO - Allow for moving overlays via a click-drag
                POINT lpPoint;
                Win32Helper.GetCursorPos(out lpPoint);

                Win32Helper.GetWindowRect(windowHandle, out GameWindow);

                GameWindow.width = GameWindow.right - GameWindow.left;
                GameWindow.height = GameWindow.bottom - GameWindow.top;

                if (_location == Location.Center)                 
                    _window.Move(
                        // Absolute position of game window plus half the game width window, then subtract half the width of the overlay to center it properly.
                        GameWindow.left + (GameWindow.width / 2) - (Width / 2) + OffsetX,
                        // Absolute position of game window plus half the game height window, then subtract half the height of the overlay to center it properly.
                        GameWindow.top + (GameWindow.height / 2) - (Height / 2) + OffsetY);
                else if (_location == Location.TopLeft)
                    _window.Move(
                        // Absolute position of game window plus half the game width window, then subtract half the width of the overlay to center it properly.
                        GameWindow.left + OffsetX,
                        // Absolute position of game window
                        GameWindow.top + OffsetY);
                else
                    _window.Move(GameWindow.left + OffsetX, GameWindow.top + OffsetY);

                _attachedToWindow = true;
            }
        }

        public void Run()
        {
            _window.Create();
            _window.Join();
        }

        public virtual void RefreshData()
        {
        }

        public void SetupBrushes(Graphics gfx)
        {
            _brushes["black"] = gfx.CreateSolidBrush(0, 0, 0);
            _brushes["white"] = gfx.CreateSolidBrush(255, 255, 255);
            _brushes["red"] = gfx.CreateSolidBrush(255, 0, 0);
            _brushes["orange"] = gfx.CreateSolidBrush(255, 143, 0);
            _brushes["yellow"] = gfx.CreateSolidBrush(255, 255, 0);
            _brushes["green"] = gfx.CreateSolidBrush(0, 255, 0);
            _brushes["blue"] = gfx.CreateSolidBrush(0, 0, 255);
            _brushes["purple"] = gfx.CreateSolidBrush(160, 50, 160);
            _brushes["violet"] = gfx.CreateSolidBrush(110, 50, 160);
            _brushes["indigo"] = gfx.CreateSolidBrush(60, 50, 160);
            _brushes["softBlue"] = gfx.CreateSolidBrush(50, 100, 160);
            _brushes["softGreen"] = gfx.CreateSolidBrush(50, 150, 160);
            _brushes["background"] = gfx.CreateSolidBrush(0x33, 0x36, 0x3F, 0.00f);
            _brushes["backgroundGray"] = gfx.CreateSolidBrush(0x33, 0x36, 0x3F, 0.8f);
            _brushes["grid"] = gfx.CreateSolidBrush(255, 255, 255, 0.2f);
            _brushes["random"] = gfx.CreateSolidBrush(0, 0, 0);

            _brushes["transparent"] = gfx.CreateSolidBrush(0, 0, 0, 0.00f);
            _brushes["transparentBlack"] = gfx.CreateSolidBrush(0, 0, 0, 0.5f);
            _brushes["transparentWhite"] = gfx.CreateSolidBrush(255, 255, 255, 0.5f);

            _brushes["transparentRed"] = gfx.CreateSolidBrush(255, 0, 0, 0.5f);
            _brushes["transparentYellow"] = gfx.CreateSolidBrush(255, 255, 0, 0.5f);
            _brushes["transparentGreen"] = gfx.CreateSolidBrush(0, 255, 0, 0.5f);
        }

        ~Overlay()
        {
            Dispose(false);
        }

        #region IDisposable

        private bool disposedValue;

        private void _window_DestroyGraphics(object sender, DestroyGraphicsEventArgs e)
        {
            foreach (var pair in _brushes) pair.Value.Dispose();
            foreach (var pair in _fonts) pair.Value.Dispose();
            foreach (var pair in _images) pair.Value.Dispose();
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                _window.Dispose();

                disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
